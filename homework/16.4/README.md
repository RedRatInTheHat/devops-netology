## Задача 1
1. Сделайте в своем github пространстве fork репозитория ```https://github.com/netology-code/shvirtd-example-python/blob/main/README.md```.   
2. Создайте файл с именем ```Dockerfile.python``` для сборки данного проекта(для 3 задания изучите https://docs.docker.com/compose/compose-file/build/ ). Используйте базовый образ ```python:3.9-slim```. Протестируйте корректность сборки. Не забудьте dockerignore. 
3. (Необязательная часть, *) Изучите инструкцию в проекте и запустите web-приложение без использования docker в venv. (Mysql БД можно запустить в docker run).
4. (Необязательная часть, *) По образцу предоставленного python кода внесите в него исправление для управления названием используемой таблицы через ENV переменную.

### Решение 1

1. Создан [форк](https://github.com/RedRatInTheHat/shvirtd-example-python)
2. Создаём [Dockerfile.python](https://github.com/RedRatInTheHat/shvirtd-example-python/blob/main/Dockerfile.python), а из него – образ. <br/>
Для проверки работоспособности поднимаем небольшой стенд:

```bash
docker network create --subnet=172.20.0.0/16 web
docker run -d --network='web' --ip 172.20.0.5 --hostname='db' -e 'MYSQL_ROOT_PASSWORD=very_strong' -e 'MYSQL_DATABASE=example' -e 'MYSQL_USER=app' -e 'MYSQL_PASSWORD=very_strong' --name mysql mysql:8
docker run -d --network='web' -e 'DB_HOST=172.20.0.5' --name web -p 8080:5000 listener:0.2
```

Успешно получаем значения из контейнера:

![alt text](images/16.4.1.1.png)

3. Запускаем `main.py` (почти) безо всяких этих докеров:

![alt text](images/16.4.1.2.png)

Проверяем:

![alt text](images/16.4.1.3.png)

![alt text](images/16.4.1.4.png)

4. Добавим возможность задавать имя таблицы. Для этого модифицируются файлы [Dockerfile.python](https://github.com/RedRatInTheHat/shvirtd-example-python/blob/main/Dockerfile.python) (добавляется значение по умолчанию) и [main.py](https://github.com/RedRatInTheHat/shvirtd-example-python/blob/main/main.py) (собственно, функционал установки имени таблицы).

Проверяем:

![alt text](images/16.4.1.5.png)

Контейнер запускается, что уже хорошо.

Проверим наличие таблицы:

![alt text](images/16.4.1.6.png)

Присутствует.

---

## Задача 2 (*)
1. Создайте в yandex cloud container registry с именем "test" с помощью "yc tool" . [Инструкция](https://cloud.yandex.ru/ru/docs/container-registry/quickstart/?from=int-console-help)
2. Настройте аутентификацию вашего локального docker в yandex container registry.
3. Соберите и залейте в него образ с python приложением из задания №1.
4. Просканируйте образ на уязвимости.
5. В качестве ответа приложите отчет сканирования.

### Решение 2

Загружаем образ, именуемый `listener`:

![alt text](images/16.4.2.0.png)

Сканируем:

![alt text](images/16.4.2.1.png)

Не очень-то безопасный образ получился.

---

## Задача 3
1. Изучите файл "proxy.yaml"
2. Создайте в репозитории с проектом файл ```compose.yaml```. С помощью директивы "include" подключите к нему файл "proxy.yaml".
3. Опишите в файле ```compose.yaml``` следующие сервисы: 

- ```web```. Образ приложения должен ИЛИ собираться при запуске compose из файла ```Dockerfile.python``` ИЛИ скачиваться из yandex cloud container registry(из задание №2 со *). Контейнер должен работать в bridge-сети с названием ```backend``` и иметь фиксированный ipv4-адрес ```172.20.0.5```. Сервис должен всегда перезапускаться в случае ошибок.
Передайте необходимые ENV-переменные для подключения к Mysql базе данных по сетевому имени сервиса ```web``` 

- ```db```. image=mysql:8. Контейнер должен работать в bridge-сети с названием ```backend``` и иметь фиксированный ipv4-адрес ```172.20.0.10```. Явно перезапуск сервиса в случае ошибок. Передайте необходимые ENV-переменные для создания: пароля root пользователя, создания базы данных, пользователя и пароля для web-приложения.Обязательно используйте уже существующий .env file для назначения секретных ENV-переменных!

2. Запустите проект локально с помощью docker compose , добейтесь его стабильной работы: команда ```curl -L http://127.0.0.1:8090``` должна возвращать в качестве ответа время и локальный IP-адрес. Если сервисы не стартуют воспользуйтесь командами: ```docker ps -a ``` и ```docker logs <container_name>``` 

5. Подключитесь к БД mysql с помощью команды ```docker exec <имя_контейнера> mysql -uroot -p<пароль root-пользователя>``` . Введите последовательно команды (не забываем в конце символ ; ): ```show databases; use <имя вашей базы данных(по-умолчанию example)>; show tables; SELECT * from requests LIMIT 10;```.

6. Остановите проект. В качестве ответа приложите скриншот sql-запроса.

### Решение 3

Контейнеры успешно поднялись; через некоторое время контейнер web получает возможность достучаться до mysql, запускается и корректно принимает запросы:

![alt text](images/16.4.3.1.png)

Подключаемся к контейнеру с mysql и просматриваем, что у нас там получилось (правда, используется другое имя таблицы, использованное для тестирования задания 2):

![alt text](images/16.4.3.2.png)

Останавливаем всё это хозяйство через `docker compose down`.

---

## Задача 4
1. Запустите в Yandex Cloud ВМ (вам хватит 2 Гб Ram).
2. Подключитесь к Вм по ssh и установите docker.
3. Напишите bash-скрипт, который скачает ваш fork-репозиторий в каталог /opt и запустит проект целиком.
4. Зайдите на сайт проверки http подключений, например(или аналогичный): ```https://check-host.net/check-http``` и запустите проверку вашего сервиса ```http://<внешний_IP-адрес_вашей_ВМ>:8090```. Таким образом трафик будет направлен в ingress-proxy.
5. (Необязательная часть) Дополнительно настройте remote ssh context к вашему серверу. Отобразите список контекстов и результат удаленного выполнения ```docker ps -a```
6. В качестве ответа повторите  sql-запрос и приложите скриншот с данного сервера, bash-скрипт и ссылку на fork-репозиторий.

### Решение 4

Запущена виртуальная машина с ОС Ubuntu 22.

Скриптом [start-compose.sh](start-compose.sh) добавлено подключение к репозиторию yandex, скачиваение репозитория и поднятие проекта.

Для подключения к репозиторию используется допольнительный файл `secret.sh`, содержащий токен. Путь к нему захардкожен, при необходимости можно доработать.<br/>

Для docker добавлен контекст `ssh-ubu` и далее для подключения используется этот контекст:

![alt text](images/16.4.4.1.png)

С помощью `https://check-host.net/check-http` была организована атака запросами. Правда, по большей части неудачно (были возвращены 502 и даже 503 ошибки), так что было запущено несколько набегов, чтобы собрать более-менее презентабельную таблицу:

![alt text](images/16.4.4.2.png)

---

## Задача 5 (*)
1. Напишите и задеплойте на вашу облачную ВМ bash скрипт, который произведет резервное копирование БД mysql в директорию "/opt/backup" с помощью запуска в сети "backend" контейнера из образа ```schnitzler/mysqldump``` при помощи ```docker run ...``` команды. Подсказка: "документация образа."
2. Протестируйте ручной запуск
3. Настройте выполнение скрипта раз в 1 минуту через cron, crontab или systemctl timer. Придумайте способ не светить логин/пароль в git!!
4. Предоставьте скрипт, cron-task и скриншот с несколькими резервными копиями в "/opt/backup"

### Решение 5

Для создания бэкапов создан скрипт [run-backup.sh](run-backup.sh). Как и в предыдущем задании, переменные, содержащие данные о БД, вынесены в скрипт `secret.sh`.

При запуске образа `schnitzler/mysqldump` выяснилось, что с `mysql:8` поменялся используемый плагин аутентификации, и так просто уже не подключишься:<br/>
`ERROR 1045 (28000): Plugin caching_sha2_password could not be loaded: Error loading shared library /usr/lib/mariadb/plugin/caching_sha2_password.so: No such file or directory`

Тут было 3 путя:
1. Использовать mysql версии 5.
2. Каждый раз скачивать `mariadb-connector-c-dev` в контейнер.
3. Собрать свой образ на основе `schnitzler/mysqldump` с нужной библиотекой.

В решении используется 2 вариант как компромисный. В боевом решении, конечно, нужно было бы использовать вариант 3.

Вызовом `crontab -e` создан файл [root](root), где настроен ежеминутный вызов написанного скрипта.<br/>
Файлы исправно складываются в `/opt/backup`:

![alt text](images/16.4.5.1.png)

---

## Задача 6
Скачайте docker образ ```hashicorp/terraform:latest``` и скопируйте бинарный файл ```/bin/terraform``` на свою локальную машину, используя dive и docker save.
Предоставьте скриншоты  действий .


## Задача 6.1
Добейтесь аналогичного результата, используя docker cp.  
Предоставьте скриншоты  действий .

## Задача 6.2 (**)
Предложите способ извлечь файл из контейнера, используя только команду docker build и любой Dockerfile.  
Предоставьте скриншоты  действий .

### Решение 6

#### dive + docker save

Скачиваем `dive` и исследуем им `hashicorp/terraform:latest`. Находим слой, где в `/bin/terraform` копируется искомый файл:

![alt text](images/16.4.6.1.png)

Сохраняем образ в `terraform.tar`:

![alt text](images/16.4.6.2.png)

А потом распаковываем эту матрёшку, завершая слоем `1bac...`, найденным ранее:

![alt text](images/16.4.6.3.png)

Файл успешно получен.

#### docker cp

Запускаем контейнер terraform и бессовестно копируем оттуда файл `/bin/terraform`

![alt text](images/16.4.6.4.png)

#### docker build

Для извлечения только нужного файла создаём отдельный слой, куда утаскиваем файл terraform. Получаем забавный файл [Docker.terraform](Dockerfile.terraform)

Собираем файл с опцией `--output` и заимствуем файл:

![alt text](images/16.4.6.5.png)

---

## Задача 7 (***)
Запустите ваше python-приложение с помощью runC, не используя docker или containerd.  
Предоставьте скриншоты  действий .

### Решение 7

Решение, к сожалению, выполнено с некоторыми допущениями и с большой оговоркой: приложение запускается, но не значит, что работает.

Допущение 1. Образ предварительно залит в docker hub, чтобы после этого `skopeo` мог его стащить, а `umoci` – распаковать. Получаем:

![alt text](images/16.4.7.1.png)

Теперь у нас есть директории `listener` и `bundle`.

Из второй утаскиваем директорию `rootfs` и файл `config.json` и ~~объединяем как карандаш и банан~~ складываем в `listener`:

![alt text](images/16.4.7.2.png)

Корректируем `config.json` (устанавливаем terminal = false) и запускаем с помощью `runc`:

![alt text](images/16.4.7.3.png)

Контейнер запускается, но падает, резонно сообщая, что база данных обнаружена не была. И тут уже либо как-то хитро запускать и прокидывать mysql (просто схитрить и поднять контейнер не получилось), либо собирать контейнер с БД и как-то поднимать сеть. <br/>
Засим это погружение в кроличью нору было завершено сохранения нервов для.

---